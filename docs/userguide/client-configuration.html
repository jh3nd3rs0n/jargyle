<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M13 from src/site/markdown/userguide/client-configuration.md at 2024-01-30
 | Rendered using Apache Maven Fluido Skin 2.0.0-M8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M13" />
    <title>Jargyle – Client Configuration</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-2.0.0-M8.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-2.0.0-M8.min.js"></script>
<link rel="stylesheet" href="./css/default.min.css">
<script src="./js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2024-01-30<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 5.0.0-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="../index.html">Introduction</a></li>
    <li><a href="../licenses.html">Licenses</a></li>
    <li><a href="../releases.html">Releases</a></li>
   <li class="nav-header">User Guide</li>
    <li><a href="../userguide/client-api.html">Client API</a></li>
    <li class="active"><a>Client Configuration</a></li>
    <li><a href="../userguide/cli.html">Command Line Interface</a></li>
    <li><a href="../userguide/server-api.html">Server API</a></li>
    <li><a href="../userguide/server-configuration.html">Server Configuration</a></li>
   <li class="nav-header">Reference</li>
    <li><a href="../reference/client-properties.html">Client Properties</a></li>
    <li><a href="../reference/cli-help-info.html">Command Line Interface Help Information</a></li>
    <li><a href="../reference/rule-conditions.html">Rule Conditions</a></li>
    <li><a href="../reference/rule-results.html">Rule Results</a></li>
    <li><a href="../reference/server-configuration-file-schema.html">Server Configuration File Schema</a></li>
    <li><a href="../reference/server-configuration-settings.html">Server Configuration Settings</a></li>
    <li><a href="../reference/socks5-resolve-command.html">SOCKS5 RESOLVE Command</a></li>
    <li><a href="../reference/value-syntaxes.html">Value Syntaxes</a></li>
   <li class="nav-header">API Documentation</li>
    <li><a href="../apidocs/index.html">Javadoc</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
   <li class="nav-header">Modules</li>
    <li><a href="../jargyle-client/index.html">Jargyle Client</a></li>
    <li><a href="../jargyle-common/index.html">Jargyle Common</a></li>
    <li><a href="../jargyle-internal/index.html">Jargyle Internal</a></li>
    <li><a href="../jargyle-protocolbase/index.html">Jargyle Protocolbase</a></li>
    <li><a href="../jargyle-server/index.html">Jargyle Server</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section>
<h1>Client Configuration</h1>
<p>The following are topics for configuring the client from the client API.</p><section>
<h2>Page Contents</h2>
<ul>

<li><a href="#enabling-ssl-tls-for-tcp-traffic-between-the-client-and-the-socks-server">Enabling SSL/TLS for TCP Traffic Between the Client and the SOCKS Server</a></li>
<li><a href="#enabling-dtls-for-udp-traffic-between-the-client-and-the-socks-server">Enabling DTLS for UDP Traffic Between the Client and the SOCKS Server</a></li>
<li><a href="#accessing-the-socks-server-using-socks5-authentication">Accessing the SOCKS Server Using SOCKS5 Authentication</a>
<ul>

<li><a href="#accessing-the-socks-server-using-no-authentication">Accessing the SOCKS Server Using No Authentication</a></li>
<li><a href="#accessing-the-socks-server-using-username-password-authentication">Accessing the SOCKS Server Using Username Password Authentication</a></li>
<li><a href="#accessing-the-socks-server-using-gss-api-authentication">Accessing the SOCKS Server Using GSS-API Authentication</a></li>
</ul></li>
<li><a href="#resolving-host-names-from-the-socks5-server">Resolving Host Names From the SOCKS5 Server</a></li>
<li><a href="#chaining-to-a-specified-chain-of-socks-servers">Chaining to a Specified Chain of SOCKS Servers</a></li>
</ul></section><section>
<h2>Enabling SSL/TLS for TCP Traffic Between the Client and the SOCKS Server</h2>
<p>You can enable SSL/TLS for TCP traffic between the client and the SOCKS server
under the following condition:</p>
<ul>

<li>The SOCKS server accepts SSL/TLS connections.</li>
</ul>
<p>By default SSL/TLS for TCP traffic between the client and the SOCKS server is
disabled. To enable SSL/TLS for TCP traffic between the client and the SOCKS
server, you will need to have the property <code>socksClient.ssl.enabled</code> set
to <code>true</code>. In addition, you will need to have the property
<code>socksClient.ssl.trustStoreFile</code> to specify the SOCKS server's key store
file used as a trust store (this file would need to be created by Java's keytool
utility). Also, you will need to have the property
<code>socksClient.ssl.trustStorePassword</code> to specify the password for the
SOCKS server's trust store file.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(&quot;socksClient.ssl.enabled&quot;, &quot;true&quot;);
        System.setProperty(&quot;socksClient.ssl.trustStoreFile&quot;, &quot;jargyle.jks&quot;);
        System.setProperty(&quot;socksClient.ssl.trustStorePassword&quot;, &quot;password&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div>
<p>If the SOCKS server wants the client to authenticate using SSL/TLS, you will
need to have the property <code>socksClient.ssl.keyStoreFile</code> to specify the
client's key store file (this file would need to be created by Java's keytool
utility). Also, you will need to have the property
<code>socksClient.ssl.keyStorePassword</code> to specify the password for the
client's key store file.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(&quot;socksClient.ssl.enabled&quot;, &quot;true&quot;);
        System.setProperty(&quot;socksClient.ssl.keyStoreFile&quot;, &quot;client.jks&quot;);
        System.setProperty(&quot;socksClient.ssl.keyStorePassword&quot;, &quot;drowssap&quot;);
        System.setProperty(&quot;socksClient.ssl.trustStoreFile&quot;, &quot;jargyle.jks&quot;);
        System.setProperty(&quot;socksClient.ssl.trustStorePassword&quot;, &quot;password&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div></section><section>
<h2>Enabling DTLS for UDP Traffic Between the Client and the SOCKS Server</h2>
<p>You can enable DTLS for UDP traffic between the client and the SOCKS server
under the following condition:</p>
<ul>

<li>The SOCKS server accepts DTLS connections.</li>
</ul>
<p>By default DTLS for UDP traffic between the client and the SOCKS server is
disabled. To enable DTLS for UDP traffic between the client and the SOCKS
server, you will need to have the property <code>socksClient.dtls.enabled</code> set
to <code>true</code>. In addition, you will need to have the property
<code>socksClient.dtls.trustStoreFile</code> to specify the SOCKS server's key store
file used as a trust store (this file would need to be created by Java's keytool
utility). Also, you will need to have the property
<code>socksClient.dtls.trustStorePassword</code> to specify the password for the
SOCKS server's trust store file.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(&quot;socksClient.dtls.enabled&quot;, &quot;true&quot;);
        System.setProperty(&quot;socksClient.dtls.trustStoreFile&quot;, &quot;jargyle.jks&quot;);
        System.setProperty(&quot;socksClient.dtls.trustStorePassword&quot;, &quot;password&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div>
<p>If the SOCKS server wants the client to authenticate using DTLS, you will need
to have the property <code>socksClient.dtls.keyStoreFile</code> to specify the
client's key store file (this file would need to be created by Java's keytool
utility). Also, you will need to have the property
<code>socksClient.dtls.keyStorePassword</code> to specify the password for the
client's key store file.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(&quot;socksClient.dtls.enabled&quot;, &quot;true&quot;);
        System.setProperty(&quot;socksClient.dtls.keyStoreFile&quot;, &quot;client.jks&quot;);
        System.setProperty(&quot;socksClient.dtls.keyStorePassword&quot;, &quot;drowssap&quot;);
        System.setProperty(&quot;socksClient.dtls.trustStoreFile&quot;, &quot;jargyle.jks&quot;);
        System.setProperty(&quot;socksClient.dtls.trustStorePassword&quot;, &quot;password&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div></section><section>
<h2>Accessing the SOCKS Server Using SOCKS5 Authentication</h2>
<p>The client has the following SOCKS5 authentication methods to choose from when
accessing the SOCKS5 server:</p>
<ul>

<li><code>NO_AUTHENTICATION_REQUIRED</code>: No authentication required</li>
<li><code>GSSAPI</code>: GSS-API authentication</li>
<li><code>USERNAME_PASSWORD</code>: Username password authentication</li>
</ul>
<p>From the API, you can have one or more of the aforementioned authentication
methods set in the property <code>socksClient.socks5.methods</code> as a comma
separated list.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(
            &quot;socksClient.socks5.methods&quot;, 
            &quot;NO_AUTHENTICATION_REQUIRED,GSSAPI&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div>
<p>If not set, the default value for the property <code>socksClient.socks5.methods</code>
is set to <code>NO_AUTHENTICATION_REQUIRED</code>.</p><section>
<h3>Accessing the SOCKS Server Using No Authentication</h3>
<p>Because the default value for the property <code>socksClient.socks5.methods</code> is
set to <code>NO_AUTHENTICATION_REQUIRED</code>, it is not required for
<code>NO_AUTHENTICATION_REQUIRED</code> to be included in the property
<code>socksClient.socks5.methods</code>.</p>
<p>However, if other authentication methods are to be used in addition to
<code>NO_AUTHENTICATION_REQUIRED</code>, <code>NO_AUTHENTICATION_REQUIRED</code> must be
included in the property <code>socksClient.socks5.methods</code></p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(
            &quot;socksClient.socks5.methods&quot;, 
            &quot;NO_AUTHENTICATION_REQUIRED,GSSAPI,USERNAME_PASSWORD&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div></section><section>
<h3>Accessing the SOCKS Server Using Username Password Authentication</h3>
<p>To access the SOCKS server using username password authentication, you
will need to have the property <code>socksClient.socks5.methods</code> to have
<code>USERNAME_PASSWORD</code> included. You will also need to have the properties
<code>socksClient.socks5.userpassmethod.username</code> and
<code>socksClient.socks5.userpassmethod.password</code> respectively specify the
username and password for the SOCKS5 server.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(
            &quot;socksClient.socks5.methods&quot;, &quot;USERNAME_PASSWORD&quot;);
        System.setProperty(
            &quot;socksClient.socks5.userpassmethod.username&quot;, 
            &quot;Aladdin&quot;);
        System.setProperty(
            &quot;socksClient.socks5.userpassmethod.password&quot;,
            &quot;opensesame&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div></section><section>
<h3>Accessing the SOCKS Server Using GSS-API Authentication</h3>
<p>To access the SOCKS server using GSS-API authentication, you will need to have
the property <code>socksClient.socks5.methods</code> to have <code>GSSAPI</code> included. You
will also need to specify Java system properties to use a security mechanism
that implements the GSS-API (for example, Kerberos is a security mechanism that
implements the GSS-API) and you will also need to specify the GSS-API service
name for the SOCKS5 server.</p>
<p>The following is a sufficient example of using the Kerberos security mechanism:</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(
            &quot;javax.security.auth.useSubjectCredsOnly&quot;, &quot;false&quot;);
        System.setProperty(
            &quot;java.security.auth.login.config&quot;, &quot;login.conf&quot;);
        System.setProperty(&quot;java.security.krb5.conf&quot;, &quot;krb5.conf&quot;);
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        System.setProperty(&quot;socksClient.socks5.methods&quot;, &quot;GSSAPI&quot;);
        System.setProperty(
            &quot;socksClient.socks5.gssapimethod.serviceName&quot;,
            &quot;rcmd/jargyle.net&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        // ...
    }
}
</code></pre></div>
<p>The Java system property <code>javax.security.auth.useSubjectCredsOnly</code> with
the value <code>false</code> disables JAAS-based authentication to obtain the credentials
directly and lets the underlying security mechanism obtain them instead.</p>
<p>The Java system property <code>java.security.auth.login.config</code> with the value
<code>login.conf</code> provides a JAAS configuration file for the underlying security
mechanism.</p>
<p><code>login.conf</code>:</p>

<div class="verbatim">
<pre><code class="language-text">com.sun.security.jgss.initiate {
  com.sun.security.auth.module.Krb5LoginModule required
  principal=&quot;alice&quot;
  useKeyTab=true
  keyTab=&quot;alice.keytab&quot;
  storeKey=true;
};
</code></pre></div>
<p>In <code>login.conf</code>, <code>alice</code> is a principal that is created by a Kerberos
administrator.</p>
<p>Also in <code>login.conf</code>, <code>alice.keytab</code> is a keytab file also created by a
Kerberos administrator that contains the aforementioned principal and its
respective encrypted key.</p>
<p>The Java system property <code>java.security.krb5.conf</code> with the value
<code>krb5.conf</code> provides the Kerberos configuration file that points to the
Kerberos Key Distribution Center (KDC) for authentication.</p>
<p><code>krb5.conf</code>:</p>

<div class="verbatim">
<pre><code class="language-text">[libdefaults]
    kdc_realm = JARGYLE.NET
    default_realm = JARGYLE.NET
    udp_preference_limit = 4096
    kdc_tcp_port = 4444
    kdc_udp_port = 4444

[realms]
    JARGYLE.NET = {
        kdc = jargyle.net:4444
    }
</code></pre></div>
<p>In <code>krb5.conf</code>, a KDC is defined as running at the address <code>jargyle.net</code> on
port <code>4444</code> with its realm as <code>JARGYLE.NET</code>. (In a production environment,
the address <code>jargyle.net</code> should be replaced by the actual address or name of
the machine of where the KDC resides. Also, in a production environment, the
realm <code>JARGYLE.NET</code> should be replaced by an actual realm provided by a
Kerberos administrator.)</p>
<p>The property <code>socksClient.socks5.gssapimethod.serviceName</code> with the value
<code>rcmd/jargyle.net</code> is the GSS-API service name (or the Kerberos service
principal) for the SOCKS server residing at the address <code>jargyle.net</code>. (In
a production environment, the address <code>jargyle.net</code> should be replaced by the
name of the machine of where the SOCKS server resides.)</p></section></section><section>
<h2>Resolving Host Names From the SOCKS5 Server</h2>
<p>By default, host name resolution from the SOCKS5 server occurs only when a
<code>Socket</code> is created with a host name and port number.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        Socket socket = netObjectFactory.newSocket(&quot;google.com&quot;, 443);
        // ...
    }
}
</code></pre></div>
<p>The client API comes with a <code>HostResolver</code> object to resolve host names. By
default the <code>HostResolver</code> object resolves host names through the local
system. To enable the <code>HostResolver</code> object to have the host names resolved
from the SOCKS5 server instead, you would need to set the property
<code>socksClient.socks5.useResolveCommand</code> set to <code>true</code>. This property can
only be used if the SOCKS5 server supports the SOCKS5 RESOLVE command.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        System.setProperty(&quot;socksServerUri.scheme&quot;, &quot;socks5&quot;);
        System.setProperty(&quot;socksServerUri.host&quot;, &quot;jargyle.net&quot;);
        System.setProperty(&quot;socksServerUri.port&quot;, &quot;1234&quot;);
        NetObjectFactory netObjectFactory = NetObjectFactory.newInstance();
        HostResolver hostResolver = netObjectFactory.newHostResolver();
        InetAddress inetAddress = hostResolver.resolve(&quot;google.com&quot;);
        Socket socket = netObjectFactory.newSocket(inetAddress, 443);
        // ...
    }
}
</code></pre></div></section><section>
<h2>Chaining to a Specified Chain of SOCKS Servers</h2>
<p>You can have the client chained to a specified chain of SOCKS servers, meaning
that the traffic can be routed through the specified chain of SOCKS servers. To
do this, you will need to create a chain of <code>SocksClient</code> objects with each
<code>SocksClient</code> object specifying a SOCKS server.</p>
<p>API example:</p>

<div class="verbatim">
<pre><code class="language-java">package com.example;

import com.github.jh3nd3rs0n.jargyle.client.HostResolver;
import com.github.jh3nd3rs0n.jargyle.client.NetObjectFactory;
import com.github.jh3nd3rs0n.jargyle.client.Properties;
import com.github.jh3nd3rs0n.jargyle.client.Scheme;
import com.github.jh3nd3rs0n.jargyle.client.SocksClient;

import java.io.IOException;

import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;

public class ClientApp {
    public static void main(String[] args) throws IOException {
        SocksClient socksClient1 = Scheme.SOCKS5
            .newSocksServerUri(&quot;betabeta.net&quot;, &quot;3456&quot;)
            .newSocksClient(Properties.of());
        SocksClient socksClient2 = Scheme.SOCKS5
            .newSocksServerUri(&quot;alphaalpha.net&quot;, &quot;2345&quot;)
            .newSocksClient(Properties.of(), socksClient1);
        SocksClient socksClient3 = Scheme.SOCKS5
            .newSocksServerUri(&quot;jargyle.net&quot;, &quot;1234&quot;)
            .newSocksClient(Properties.of(), socksClient2);
        NetObjectFactory netObjectFactory = 
            socksClient3.newSocksNetObjectFactory();
        // ...
    }
}
</code></pre></div>
<p>The known limitations of chaining to a specified chain of SOCKS servers include
the following:</p>
<ul>

<li>Only TCP traffic can be routed through the chain. The client will attempt to
route any UDP traffic through the last SOCKS server of the chain.</li>
</ul></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2024
<a href="https://github.com/jh3nd3rs0n">jh3nd3rs0n</a>
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
